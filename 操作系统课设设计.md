命名规范：

* 尽量使用全称，不要使用缩写，除了被广泛传播的缩写代号
* 类，结构体，函数命名都采用大驼峰命名法，如：`struct ExampleStruct`,`class ExampleClass`,`void ExampleFunc()`

* 文件名全小写，如`disk_manage.cpp`
* 普通变量和结构体变量全部小写，单词之间用下划线连接，如`int day_count`
* 类数据成员同普通变量，但是在最后需要接一个下划线，如：`char file_name_`
* 常量命名以'k'开头，之后大驼峰，如：`const int kFilenameLength = 10`
* 宏变量全大写，单词之间用下划线连接，如：`define PI_ROUNDED 3.0`



```c++

//文件节点
struct Filenode {
    char filename[FILENAME_LENGTH];
    bool is_dir;
    FCB *fcb;
    Filenode *parent;
    Filenode *child;
    Filenode *next;
    Filenode *prev;
}

//文件控制块
struct FCB {
    char filename[FILENAME_LENGTH];
    int quote_count;
    bool is_dir;
    int size;
    int file_inode_addr;
}

//在开机的时候将根目录的磁盘块地址加载进内存，从根目录就可以往下找
```





**类**

* 磁盘：

```c++
Class DiskManage{
    //读取块
    char* get_block();
    
    //设置块
    void set_block();
}
```





### 行为

**文件目录结构**

* 初始化文件根目录：`InitRoot()`
  * 调用`InitFilenode()`创建一个目录
  * 创建对应的FCB
* 创建文件或目录的存储节点：`InitFilenode()`
* 创建文件或目录对应的FCB：`InitFCB()`

* 创建一个文件：`CreateFile()`
  * 调用`InitFilenode()`创建一个文件
  * 在文件目录中新增一个FCB
* 删除一个文件：`DeleteFile()`
  * 判断是否读进内存，
  * 根据`index_table`的数据将位示图修改
  * 删除对应的FCB

* 创建一个目录：`CreateDir()`
  * 调用`InitFilenode()`创建一个目录
  * 创建对应的FCB
* 删除一个目录：`DeleteDir()`
  * 检测目录下是否有文件或目录，有则不能删除
  * 根据`index_table`的数据将位视图修改（目录记录的数据为该目录下存放的其他目录和文件）
  * 删除对应的FCB
* 读取一个文件：`ReadFile()`
  * 根据文件名查找当前目录下的文件
  * 找到文件后通过指针找对应的FCB，通过`index_table`获取文件数据块地址
  * 调用`get_block`获取文件内容
* 写入一个文件：`WriteFile()`
  * 根据文件名查找当前目录下的文件
  * 找到文件后通过指针找对应的FCB，通过`index_table`获取文件数据块地址
  * 读取输入，调用`DivideAndStorage()`将数据写入磁盘，更新`index_table`和`bitmap`
* 将文件分片并写入磁盘：`DivideAndStorage()`
  * 一个`char`一个字节，一个磁盘块40B，可以存放40个字符
  * 设定输入的只能是英文字符，将输入除40计算需要多少磁盘块，向上取整
  * 调用`set_block()`写入磁盘

**磁盘**

* 初始化磁盘文件：`InitDisk()`

  * 创建磁盘文件（文件格式是什么？）
  * 划分文件区和兑换区
  * 

* 初始化位示图：`InitBitmap()`

  * 对位示图进行二进制数的读写，用1表示该磁盘块已经分配出去了，0表示磁盘块空闲
  * 位示图的数据存放在磁盘第0~3块，

* 写入磁盘块：`set_block()`

* 读取磁盘块：`get_block()`

  

**内存**

* 



**进程**

* 删除数据（文件）进程：
  * **先与文件管理进程通信，传输要删除的文件或目录的地址信息**，将对应的FCB读进内存
  * 检查`is_open`，判断文件是否被其他进程打开，如果打开则报错：无法删除
  * 如果没打开，文件管理进程将结果传回，**该进程则与磁盘管理进程通信**，让其将位示图修改，然后删除对应的`Filenode`和`FCB`
* 数据生成进程
  * **将给定数据大小（按字节计算）、数据信息（英文字母）、存储目录、文件名传输到文件管理进程**
  * 文件管理进程与磁盘管理进程通信，将数据大小和数据信息传输过去，然后磁盘管理进程分配磁盘块，修改位示图，将磁盘块号传输给文件管理进程
  * 文件管理进程根据信息构建`Filenode`和`FCB`
* 执行进程
  * **执行进程与内存管理进程通信，申请分配内存块**
  * 内存管理进程传输该执行进程的初始内存块号
  * **执行进程获取目录下文件名，将文件的文件路径和进程的初始内存块号传输给文件管理进程**
  * 文件管理进程将数据和进程的**初始内存块号**传给内存管理进程
  * 内存管理进程接收数据，写入内存块，如果写不完，进行调页，将需要调页的块中的数据传输给磁盘管理进程
  * 磁盘管理进程将接收的数据放入对换区
  * 接受完最后一个数据块，执行进程结束
* 文件管理进程
  * ***目录作为一种特殊的文件，存储的数据就是其目录下的目录和文件的FCB在磁盘中存储的位置***
  * 初始化根目录，定义一个变量，表示根目录的索引表存放在磁盘块的第一块，将数据和`inode`需要的属性传输给磁盘管理进程
  * 开机后，与磁盘管理进程通信，要求获取第一块磁盘块的内容（根目录对应的`inode`），获取`index_table`的值，将数据块号传输给磁盘管理进程，获取根目录下的文件和目录的FCB，根据FCB创建对应的`Filenode`
  * **获取执行进程传输过来的文件路径和进程的初始内存块号**
    * 将内存块号存放在一个局部变量
    * 根据路径找到对应的文件的`Filenode`后，转到对应的`FCB`，根据`index_table`的数据与磁盘管理进程通信，获取对应的数据，将数据存放在一个`vector<char>`中，连同之前保存的内存块号一同传输给内存管理进程
    * 修改对应`FCB`中的`quote_count`
  * **获取数据生成进程传输过来的数据大小（按字节计算）、数据信息（英文字母）、存储目录、文件名**
    * 根据存储目录信息转到当前目录
    * 将数据信息传输给磁盘管理进程，获得其返回的存放数据的块号
    * 根据数据大小，文件名，数据块号，构建`FCB`，然后构建`Filenode`
    * 将`FCB`传输给磁盘管理进程
  * **获取数据删除进程传输过来的文件或目录的地址信息**
    * 根据地址信息获取对应的`Filenode`，再找到`FCB`
    * 检查`FCB`中的`is_dir`和`quote_count`
      * 如果是目录，检查目录下是否有其他目录或文件，有则报错不给删除
      * 如果是文件，检查是否被其他内存引用，有则报错不给删除
    * 如果删除成功则返回对应的状态码
  * 初始状态从根目录开始构建文件树
    * 和磁盘管理进程通信，获取根目录的`inode`和全部数据
      * 构建根目录的`FCB`
      * 构建根目录的`Filenode`
        * 从接受的数据中截取第一条（对应根目录下第一个文件或目录的`FCB`在磁盘中存储的地址），根据地址从磁盘管理进程获取该文件或目录的`FCB`
        * 构建给文件或目录的`Filenode`
        * 根目录以这个`Filenode`作为`child`
      * 遍历剩余的数据，为`child`设置`next`
        * 根据剩余的数据，依次从磁盘管理进程获取对应的`FCB`，构建`Filenode`
        * 一条数据得到的`Filenode`的next是下一条数据得到的`Filenode`
  * 维持一个当前目录，并且构建以当前目录为起点的文件链
  * 根据路径找到对应的`Filenode`
    * 获取路径，区分是绝对路径还是相对路径
      * `/`表示绝对路径
      * `../`表示相对路径
    * 假设是

